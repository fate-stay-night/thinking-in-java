# Thinking in java
Thinking in java 4th book source code.

## 1 对象导论
### 1.1 抽象过程
### 1.2 每个对象都有一个接口
### 1.3 每个对象都提供服务
### 1.4 被隐藏的具体实现
### 1.5 复用具体实现
### 1.6 继承
### 1.7 伴随多态的可互换对象
### 1.8 单根继承结构
### 1.9 容器
### 1.10 对象的创建和生命周期
### 1.11 异常处理：处理错误
### 1.12 并发编程
### 1.13 Java与Internet
### 1.14 总结

## 2 一切都是对象
### 2.1 用引用操纵对象
### 2.2 必须由你创建所有对象
### 2.3 永远不需要销毁对象
### 2.4 创建新的数据类型
### 2.5 方法、参数和返回值
### 2.6 构建一个Java程序
### 2.7 你的第一个Java程序
### 2.8 注释和嵌入式文档
### 2.9 编码风格
### 2.10 总结

## 3 操作符
### 3.1 更简单的打印语句 
### 3.2 使用Java操作符 
### 3.3 优先级
### 3.4 赋值
### 3.5 算术操作符
### 3.6 自动递增和递减
### 3.7 关系操作符
### 3.8 逻辑操作符
### 3.9 直接常量
### 3.10 按位操作符
### 3.11 移位操作符
### 3.12 三元操作符if-else
### 3.13 字符串操作+和+=
### 3.14 使用操作符时常犯的错误
### 3.15 类型转换操作符
### 3.16 Java没有"sizeof"
### 3.17 操作符小结
### 3.18 总结

## 4 控制执行流程
### 4.1 true和false 
### 4.2 if-else 
### 4.3 迭代
### 4.4 Foreach语法
### 4.5 return
### 4.6 break和continue
### 4.7 臭名昭著的"goto"
### 4.8 switch
### 4.9 总结

## 5 初始化与清理
### 5.1 用构造器确保初始化 
### 5.2 方法重载 
### 5.3 默认构造器
### 5.4 this关键字
### 5.5 清理：终结处理和垃圾回收
### 5.6 成员初始化
### 5.7 构造器初始化
### 5.8 数组初始化
### 5.9 枚举类型
### 5.10 总结

## 6 访问权限控制
### 6.1 包：库单元 
### 6.2 Java访问权限修饰词 
### 6.3 接口和实现
### 6.4 类的访问权限
### 6.5 总结

## 7 复用类
### 7.1 组合语法 
### 7.2 继承语法 
### 7.3 代理
### 7.4 结合使用组合和继承
### 7.5 在组合与继承之间选择
### 7.6 protected关键字
### 7.7 向上转型
### 7.8 final关键字
### 7.9 初始化及类的加载
### 7.10 总结

## 8 多态
### 8.1 再论向上转型 
### 8.2 转机 
### 8.3 构造器和多态
### 8.4 协变返回类型
### 8.5 用继承进行设计
### 8.6 总结

## 9 接口
### 9.1 抽象类和抽象方法 
### 9.2 接口
### 9.3 完全解耦
### 9.4 Java的多重继承
### 9.5 通过继承来扩展接口
### 9.6 适配接口
### 9.7 接口中的域
### 9.8 嵌套接口
### 9.9 接口与工厂
### 9.10 总结

## 10 内部类
### 10.1 创建内部类
### 10.2 链接到外部类
### 10.3 使用this与new
### 10.4 内部类与向上转型
### 10.5 在方法和作用域内的内部类
### 10.6 匿名内部类
### 10.7 嵌套类
### 10.8 为什么需要内部类
### 10.9 内部类的继承
### 10.10 内部类可以被覆盖吗
### 10.11 局部内部类
### 10.12 内部类标识符
### 10.13 总结

## 11 持有对象
### 11.1 泛型和类型安全的容器
### 11.2 基本概念
### 11.3 添加一组元素
### 11.4 容器的打印
### 11.5 List
### 11.6 迭代器
### 11.7 LinkedList
### 11.8 Stack
### 11.9 Set
### 11.10 Map
### 11.11 Queue
### 11.12 Collection和Iterator
### 11.13 Foreach与迭代器
### 11.14 总结

## 12 通过异常处理错误
### 12.1 概念
### 12.2 基本异常
### 12.3 捕获异常
### 12.4 创建自定义异常
### 12.5 异常说明
### 12.6 捕获所有异常
### 12.7 Java标准异常
### 12.8 异常的限制
### 12.9 异常的限制
### 12.10 构造器
### 12.11 异常匹配
### 12.12 其他可选方式
### 12.13 异常使用指南
### 12.14 总结

## 13 字符串
### 13.1 不可变String
### 13.2 重载"+"与StringBuilder
### 13.3 无意识的递归
### 13.4 String上的操作
### 13.5 格式化输出
### 13.6 正则表达式
### 13.7 扫描输入
### 13.8 StringTokenizer
### 13.9 总结

## 14 类型信息
### 14.1 为什么需要RTTI
### 14.2 Class对象
### 14.3 类型转换前先做检查
### 14.4 注册工厂
### 14.5 instanceof和Class的等价性
### 14.6 反射：运行时的类信息
### 14.7 动态代理
### 14.8 空对象
### 14.9 接口与类型信息
### 14.10 总结

## 15 泛型
### 15.1 与C++的比较
### 15.2 简单泛型
### 15.3 泛型接口
### 15.4 泛型方法
### 15.5 匿名内部类
### 15.6 构建复杂性模型
### 15.7 擦除的神秘之处
### 15.8 擦除的补偿
### 15.9 边界
### 15.10 通配符
### 15.11 问题
### 15.12 自限定的类型
### 15.13 动态类型安全
### 15.14 异常
### 15.15 混型
### 15.16 潜在类型机制
### 15.17 对缺乏潜在类型机制的补偿
### 15.18 将函数对象用作策略
### 15.19 总结

## 16 数组
### 16.1 数组为什么特殊
### 16.2 数组是第一级对象
### 16.3 返回一个数组
### 16.4 多维数组
### 16.5 数组与泛型
### 16.6 创建测试数据
### 16.7 Arrays使用功能
### 16.8 总结

## 17 容器深入研究
### 17.1 完整的容器分类法
### 17.2 填充容器
### 17.3 Collection的功能方法
### 17.4 可选操作
### 17.5 List的功能方法
### 17.6 Set和存储顺序
### 17.7 队列
### 17.8 理解Map
### 17.9 散列与散列码
### 17.10 选择接口的不同实现
### 17.11 使用方法
### 17.12 持有引用
### 17.13 Java1.0/1.1的容器
### 17.14 总结

## 18 Java I/O系统
### 18.1 File类
### 18.2 输入和输出
### 18.3 添加属性和有用的接口
### 18.4 Reader和Writer
### 18.5 自我独立的类RandomAccessFile
### 18.6 I/O流的典型使用方式
### 18.7 文件读写的实用工具
### 18.8 标准I/O
### 18.9 进程控制
### 18.10 新I/O
### 18.11 压缩
### 18.12 对象序列化
### 18.13 XML
### 18.14 Preferences
### 18.15 总结

## 19 枚举类型
### 19.1 基本enum特性
### 19.2 向enum中添加新方法
### 19.3 switch语句中的enum
### 19.4 values()的神秘之处
### 19.5 实现，而非继承
### 19.6 随机选取
### 19.7 使用接口组织枚举
### 19.8 使用EnumSet替代标志
### 19.9 使用EnumMap
### 19.10 常量相关的方法
### 19.11 多路分发
### 19.12 总结

## 20 注解
### 20.1 基本语法
### 20.2 编写注解处理器
### 20.3 使用apt处理注解
### 20.4 将观察者模式用于apt
### 20.5 基于注解的单元测试
### 20.6 总结

## 21 并发
### 21.1 并发的多面性
### 21.2 基本的线程机制
### 21.3 共享受限资源
### 21.4 终结任务
### 21.5 线程之间的协作
### 21.6 死锁
### 21.7 新类库中的构件
### 21.8 仿真
### 21.9 性能调优
### 21.10 活动对象
### 21.11 总结
