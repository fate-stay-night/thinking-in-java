# Thinking in java
Thinking in java 4th book source code.

## 14 类型信息
### 14.1 为什么需要RTTI
### 14.2 Class对象
### 14.3 类型转换前先做检查
### 14.4 注册工厂
### 14.5 instanceof和Class的等价性
### 14.6 反射：运行时的类信息
### 14.7 动态代理
### 14.8 空对象
### 14.9 接口与类型信息
### 14.10 总结

## 15 泛型
### 15.1 与C++的比较
### 15.2 简单泛型
### 15.3 泛型接口
### 15.4 泛型方法
### 15.5 匿名内部类
### 15.6 构建复杂性模型
### 15.7 擦除的神秘之处
### 15.8 擦除的补偿
### 15.9 边界
### 15.10 通配符
### 15.11 问题
### 15.12 自限定的类型
### 15.13 动态类型安全
### 15.14 异常
### 15.15 混型
### 15.16 潜在类型机制
### 15.17 对缺乏潜在类型机制的补偿
### 15.18 将函数对象用作策略
### 15.19 总结

## 16 数组
### 16.1 数组为什么特殊
### 16.2 数组是第一级对象
### 16.3 返回一个数组
### 16.4 多维数组
### 16.5 数组与泛型
### 16.6 创建测试数据
### 16.7 Arrays使用功能
### 16.8 总结

## 17 容器深入研究
### 17.1 完整的容器分类法
### 17.2 填充容器
### 17.3 Collection的功能方法
### 17.4 可选操作
### 17.5 List的功能方法
### 17.6 Set和存储顺序
### 17.7 队列
### 17.8 理解Map
### 17.9 散列与散列码
### 17.10 选择接口的不同实现
### 17.11 使用方法
### 17.12 持有引用
### 17.13 Java1.0/1.1的容器
### 17.14 总结

## 18 Java I/O系统
### 18.1 File类
### 18.2 输入和输出
### 18.3 添加属性和有用的接口
### 18.4 Reader和Writer
### 18.5 自我独立的类RandomAccessFile
### 18.6 I/O流的典型使用方式
### 18.7 文件读写的实用工具
### 18.8 标准I/O
### 18.9 进程控制
### 18.10 新I/O
### 18.11 压缩
### 18.12 对象序列化
### 18.13 XML
### 18.14 Preferences
### 18.15 总结

## 19 枚举类型
### 19.1 基本enum特性
### 19.2 向enum中添加新方法
### 19.3 switch语句中的enum
### 19.4 values()的神秘之处
### 19.5 实现，而非继承
### 19.6 随机选取
### 19.7 使用接口组织枚举
### 19.8 使用EnumSet替代标志
### 19.9 使用EnumMap
### 19.10 常量相关的方法
### 19.11 多路分发
### 19.12 总结

## 20 注解
### 20.1 基本语法
### 20.2 编写注解处理器
### 20.3 使用apt处理注解
### 20.4 将观察者模式用于apt
### 20.5 基于注解的单元测试
### 20.6 总结

## 21 并发
### 21.1 并发的多面性
### 21.2 基本的线程机制
### 21.3 共享受限资源
### 21.4 终结任务
### 21.5 线程之间的协作
### 21.6 死锁
### 21.7 新类库中的构件
### 21.8 仿真
### 21.9 性能调优
### 21.10 活动对象
### 21.11 总结